[{"title":"uploadify插件的使用总结","path":"2017/07/15/uploadify插件的使用总结/","text":"uploadify插件的使用总结 引包 123&lt;link rel=\"stylesheet\" href=\"uploadify/uploadify.css\"&gt;&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"uploadify/jquery.uploadify.js\"&gt;&lt;/script&gt; 调用uploadify提供的方法 1&lt;input type=\"file\" id=\"file\"&gt; 1234567891011121314151617181920212223242526272829303132$(\"#file\").uploadify(&#123; //指定swf文件的路径！！！ 推荐使用绝对路径 swf: \"/views/assets/uploadify/uploadify.swf\", //指定上传文件的接口地址 uploader: \"/api/uploader/avatar\", //指定上传文件的时候，文件的键， 后台需要通过该值来获取文件的内容 fileObjName: \"tc_avatar\", //尺寸 width: 100, height: 100, //类样式，附加一个类样式给上传按钮 buttonClass: \"类名\", //按钮的文字 buttonText: \"上传图片\", //设置上传图片的大小限制，可以是一个字符串单位可以是B KB MB GB fileSizeLimit: \"100KB\", //设置上传文件的类型，也就是在选择文件的窗口中筛选指定类型的文件 fileTypeExts: '*.gif; *.jpg; *.png', //formData 在上传文件的时候，可以附带一些数据，类似于ajax提交数据 formData: &#123;key: value&#125;, //设置上传进度的模板！ itemTemplate : '&lt;p&gt;&lt;/p&gt;' //onUploadSuccess 上传成功之后的回调函数 onUploadSuccess: function(file, data, response)&#123; &#125;, //onUploadComplete //onUploadError //onUploadProgress //onUploadStart //onUploadSuccess&#125;);","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"cookie","path":"2017/06/28/cookie/","text":"cookiecookie属于浏览器中的一个存储空间，里面可以存储数据。 可以存，也可以取 cookie是以域名为单位存储的，每个域名的cookie之间是相互隔离的，也就是说不可以互相操作 比如： 在it.cn 这个域名的cookie中存了一条数据在 studyit.com 中能够使用上面存储的内容吗？？ 不可以！ cookie 是有容量限制的， 每个域名可以存储的cookie不能超过4KB 存储单位： bit 位 Byte 字节 8bit KB 千字节 1024Byte MB 兆字节 1024KByte GB 吉字节 1024MB TB 太字节 1024GB cookie 有时限的，有声明周期的，也就是说cookie是会过期的默认情况下cookie的生命会在浏览器关闭的时候结束！也可以手动的设置cookie的过期时间！ cookie也是分路径的在www.studyit.com/dashboard/index 往cookie中存储了一个数据在www.studyit.com/ 是不可以访问上面存储的内容的 子级路径中可以访问父级路径中存储的cookie，但是父级路径不能访问子级路径中存储的cookie 一般情况下，都会直接将cookie存储到根目录下面去，这样全站所有的路径中都可以访问了。 cookie存储的路径是可以设置的！ 一个域名下的cookie是在该域名下面所有的页面中都可以使用的！ www.studyit.comwww.studyit.com/dashboard/indexwww.studyit.com/teacer/add 当前域名中所有的cookie会伴随着每一次请求发送给服务器！！！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"webpack","path":"2017/06/04/webpack/","text":"在网页中会引用哪些常见的静态资源？ 图片 .png, .jpg, .gif, .bmp 字体 .svg, .ttf, .woff, .woff2, .eot CSS .css, .less, .scss JS .js, .json, .coffee 模板文件 .vue, .jade 网页中这些常见的资源多了以后会出现什么问题 在一个页面中，会引用各种各样的静态资源文件，会导致发起很多的二次请求，导致网页显示效率变慢； 需要人为去解决文件之间复杂的依赖关系； 如何解决上述两个问题 图片：使用精灵图；base64 CSS：合并；压缩混淆 JS：合并；压缩混淆 如何完美实现上述的三种解决方案 使用 Gulp 去实现上述三种解决方案； 根据官网的图片介绍webpack打包的过程 webpack官网 注意:Gulp是站在任务的角度去思考问题的；WebPack适合站在项目的角度，去统筹整个项目的构建； webpack安装的两种方式了解：Webpack只是一个工具；是基于Node.js构建出来的；所以，webpack是托管到了NPM； 全局安装：npm i -g webpack 在项目中安装：npm i webpack -D 初步使用webpack打包构建列表隔行变色案例使用webpack 需要打包的文件路径 输入的文件路径方式，进行最基本的打包；注意：这种方式，调用的是全局安装的 webpack 使用webpack的配置文件简化打包时候的命令1234567891011var path = require(&apos;path&apos;);// 使用 Node中的 module.exports 导出一个 webpack 的配置对象// 将来，当我们 直接运行 webpack 这个命令的时候，webpack会检查有没有指定要打包文件的路径，以及输出文件的路径；如果没有指定相关路径，则会默认去项目根目录中，查找一个叫做 `webpack.config.js` 的配置文件；然后得到 这个 配置文件中 导出的配置对象，拿着这个配置对象去进行打包操作；module.exports = &#123; entry: path.join(__dirname, &apos;./src/js/main.js&apos;), // 打包的入口文件 output: &#123; // 配置和输出相关的一系列参数 path: path.join(__dirname, &apos;./dist&apos;), // 指定输出文件的路径 filename: &apos;bundle.js&apos; // 通过 filename 来指定输出文件的名称 &#125;&#125; 实现webpack的实时打包构建需求：由于在实际开发中，会经常修改代码，需要时时查看最新的代码效果，所以，我们最好能够实现只要代码以修改，自动进行打包!为了实现这个需求，我们需要借助一个叫做webpack-dev-server的插件；注意：由于 webpack-dev-server 内部封装了 webpack， 所以，它的使用方式，和webpack几乎一样！ 运行npm i webpack-dev-server -D安装插件 注意：webpack-dev-server 帮我们生成出来的 bundle.js 并没有存放到实际的磁盘目录中；而是帮我们托管到了内存中；为什么不放到磁盘中,而是托管到了内存呢? 快!!! 使用html-webpack-plugin插件配置启动页面实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1：直接在package.json的scripts节点下设置:1&quot;dev1&quot;: &quot;webpack-dev-server --contentBase src --open --port 80 --hot&quot; 方式2：在 webpack.config.js中添加一个新节点:12345678devServer: &#123; // 设置 webpack-dev-server 命令的第二种形式 // --contentBase src --open --port 80 --hot contentBase: &apos;src&apos;, // 设置托管目录 open: true, // 自动打开浏览器 port: 80, // 指定打开的端口号 hot: true, // 启用热更新 openPage: &apos;index.html&apos; // 设置默认打开浏览器之后，默认显示那个页面,注意： webpack-dev-server 在 v2.5.0 之后，需要设置这一项，否则打开的是 undefined 页面 &#125; 还需要添加一个新的插件,启用热更新:1new webpack.HotModuleReplacementPlugin() // 在 插件中 启用 webpack 的热更新 webpack中loader的加载原理使用webpack打包css文件 运行npm i style-loader css-loader -D 在webpack.config.js的module节点下的rules节点中,添加一个新的loader配置项:12345module: &#123; // 所有的第三方loader，都需要配置到这个 module 节点下 rules: [ // 所有的第三方模块的匹配规则，都写到 rules 节点下 &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, // 匹配处理 .css 类型文件的loader ] &#125; 使用webpack打包sass文件 运行cnpm i sass-loader node-sass -D 添加相关loader:1&#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125; // 设置 处理 .scss 类型文件的loader 使用webpack处理css中的路径 运行npm i url-loader file-loader -D 添加相关loader:12&#123; test: /\\.(jpg|gif|png|bmp)$/, use: &apos;url-loader?limit=7631&amp;name=[hash:7]-[name].[ext]&apos; &#125;, // 处理图片资源的loader模块【注意：可以通过 limit 设置多大的文件才进行编码，只有小于指定大小的文件，才会被编码】 &#123; test: /\\.(eot|woff2|woff|ttf|svg)$/, use: &apos;url-loader&apos; &#125; // 处理字体文件 使用babel处理高级JS语法 由于webpack默认会转换一部分的高级的ES6语法,但是并不能转换全部的; 因此需要借助于Babel这个转换器,把高级的语法转换为低级别的,浏览器能识别的语法! 运行第一套命令:npm i babel-core babel-loader babel-plugin-transform-runtime -D 运行第二套命令:npm i babel-preset-es2015 babel-preset-stage-0 -D 配置loader,在rules中添加一个新的loader配置项: 1&#123; test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125; // 配置处理高级ES语法的loader 在项目根目录中创建一个.babelrc的一个Babel配置文件: 1234&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125; webpack的发布策略 在实际开发中，一般会有两套项目方案： 一套是开发期间的项目，包含了测试文件、测试数据、开发工具、测试工具等相关配置，有利于项目的开发和测试，但是这些文件仅用于开发，发布项目时候需要剔除； 另一套是部署期间的项目，剔除了那些客户用不到的测试数据测试工具和文件，比较纯净，减少了项目发布后的体积，有利于安装和部署！ 为了满足我们的发布策略，需要新建一个配置文件，命名为webpack.publish.config.js，将webpack.config.js的配置拷贝过去，剔除一些开发配置项即可： 将devServer节点删掉： 12345devServer: &#123; hot: true, open: true, port: 4321 &#125; 将plugins节点下的热更新插件删掉： 1new webpack.HotModuleReplacementPlugin() 修改url-loader，将图片放入统一的images文件夹之下： 1&#123; test: /\\.(png|jpg|gif)$/, use: &apos;url-loader?limit=43959&amp;name=images/[name].[ext]&apos; &#125; 或者使用img-前缀加上7位的hash名称：1&#123; test: /\\.(png|jpg|gif)$/, use: &apos;url-loader?limit=43959&amp;name=images/img-[hash:7].[ext]&apos; &#125; 在package.json中的script节点下新增dev命令，通过--config指定webpack启动时要读取的配置文件：1&quot;pub&quot;: &quot;webpack --config webpack.publish.config.js&quot; 每次重新构建时候删除dist目录 运行cnpm i clean-webpack-plugin --save-dev 在头部引入这个插件： 1var cleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); 在plugins节点下使用这个插件： 1new cleanWebpackPlugin([&apos;dist&apos;]) 分离第三方包改造webpack.publish.config.js 改造entry节点如下： 1234entry: &#123; app: path.resolve(__dirname, &apos;src/js/main.js&apos;), // 自己代码的入口 vendors: [&apos;jquery&apos;] // 要分离的第三方包的入口 &#125; 在plugins节点下新增插件： 1234new webpack.optimize.CommonsChunkPlugin(&#123; // 抽离第三方包的插件 name:&apos;vendors&apos;, // 指定抽离第三方包的入口名称 filename:&apos;vendors.js&apos; // 抽离出的公共模块的名称&#125;) html-webpack-plugin在生成index.html文件的时候，会自动将抽离的第三方包引入进去！ 优化压缩JS在plugins数组中添加：12345678new webpack.optimize.UglifyJsPlugin(&#123; // 优化压缩JS compress:&#123; warnings:false // 移除警告 &#125;&#125;),new webpack.DefinePlugin(&#123; // 设置为产品上线环境，进一步压缩JS代码 &apos;process.env.NODE_ENV&apos;: &apos;&quot;production&quot;&apos;&#125;) 优化压缩HTML文件在plugins节点下的htmlWebpackPlugin插件中，添加minify子节点：12345minify:&#123;// 压缩HTML代码 collapseWhitespace:true, // 合并空白字符 removeComments:true, // 移除注释 removeAttributeQuotes:true // 移除属性上的引号&#125; 其他优化项请参考：html-minifier - github 抽取CSS文件 运行npm install --save-dev extract-text-webpack-plugin安装抽取CSS文件的插件。 在配置文件中导入插件： 1const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); 修改CSS和Sass的loader如下： 1234567891011121314&#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;], publicPath: &apos;../&apos; // 设置图片路径 &#125;)&#125;,&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&apos;css-loader&apos;, &apos;sass-loader&apos;], publicPath: &apos;../&apos; // 设置图片路径 &#125;)&#125; 在plugins节点下新增插件： 1new ExtractTextPlugin(&quot;css/styles.css&quot;), // 抽取CSS文件的插件 压缩抽取出来的CSS文件 运行cnpm i optimize-css-assets-webpack-plugin --save-dev安装插件到开发依赖。 在配置文件头部导入插件： 1var OptimizeCssAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;); 在plugins节点下新增插件： 1new OptimizeCssAssetsPlugin() // 压缩CSS文件的插件 相关文章 Sass 基础教程 webpack-dev-server You have not accepted the license agreements of the following","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"远程仓库的详细操作","path":"2016/07/25/远程仓库的详细操作/","text":"远程仓库的详细操作在文件修改之后,如何将修改的内容推送到远程仓库中 要使用git pull来获取一下远程仓库中最新的代码 再使用git push将自己修改的内容推送到远程仓库中 获取服务器中更新的内容,git pull加远程地址","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"模块化内容","path":"2016/06/29/模块化内容/","text":"模块化CommonJSjs代码的模块化标准，不适用于前端开发，NodeJS在使用该标准实现模块化 AMDAsync Module Definition 异步模块定义 尽可能早的加载所有需要用到的模块，模块的加载都是异步的，如果要在模块加载完成后，利用模块中的内容实现某些功能，需要将代码写在 require的第二个参数的回调函数中 require.js CMDCommon Module Definition 通用模块定义 尽可能晚的加载模块，哪里用到了模块再去加载 sea.js ## require.js实现模块化 定义模块1234567define([\"当前模块的依赖项\"...], function(使用形参接收依赖项的返回值)&#123; //当前模块中要实现的功能 //当前模块如果要提供内容给模块调用者使用，就需要通过return语句将需要体用给别人的内容进行返回 return 需要给别人提供的内容;&#125;) 引用模块1234require([\"模块路径/模块别名\"...], function()&#123; //这个函数会在模块加载完成之后，被调用起来 //如果想在模块加载完成后实现某些功能，那么代码都写到这个函数中！&#125;) data-main在引用require.js的script标签中可以通过data-main指定一个入口文件，这个入口文件中的内容，会在reuqirejs加载完毕之后，被自动执行。 data-main指定的这个文件是异步加载的！所以在下面如果有使用这个文件中相关内容的代码，就不能够保证执行正常 路径的说明 如果直接使用script在html当中引入模块，那么模块的路径查找会以当前html文件作为基础。 （没有配置baseUrl，也没有data-main属性） 如果使用data-main属性，那么这时候的模块路径查找，会以入口文件所在的路径作为基础去查找（没有设置baseUrl） 如果通过require.config()配置了baseUrl，那么所有的模块的路径查找，都会以这个baseUrl做为基础！ require.config方法的说明这个方法主要用来配置requirejs相关的内容 123456789101112require.config(&#123; //配置基础路径，所有的模块查找都以这个路径为基础 //这个路径一般情况下配置为绝对路径，并且设置为所有模块共享的路径 baseUrl: \"/\", //paths可以用来为单个路径设置别名，以后在使用模块的时候，直接使用别名即可，不需要再写完整的路径了 //如果模块是一个具名模块，那么这个别名一定要和具名模块的名称一致 //.js 不要！！！ paths: &#123; \"jquery\": \"views/assets/jquery/jqeury.min\" &#125;&#125;); 如何加载第三方内容实现了模块化的第三方内容加载直接使用require，就像使用正常模块一样即可！ 未实现模块化的第三方内容加载 需要考虑该内容是否有依赖项 需要考虑该内容是否有返回值（是否要提供内容给外部使用）如果有依赖项，需要通过require.config方法配置该模块的依赖项 123456789101112131415161718require.config(&#123; baseUrl: \"/\", paths: &#123; \"jquery\": \"views/assets/jquery/jqeury.min\", \"animate\": \"animate/animate\" &#125;, //配置的是第三方内容的依赖项以及输出项 shim: &#123; //模块别名： 配置信息 \"animate\": &#123; //deps属性可以用来配置这个模块的依赖项 deps: [\"jquery\"], //export可以配置输出项 //输出项的内容其实就是在第三方内容中去查找和配置名称相对应的全局变量，将其值作为模块的输出值！ exports: \"animate\" &#125; &#125;&#125;); 如果第三方内容没有实现模块化，并且没有依赖项，也没有输出项，直接require即可！！！ 具名模块匿名模块具名模块有名字123define(\"名字\", [], function()&#123; &#125;) 匿名模块没名字123define([], function()&#123; &#125;)","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"git的基本使用","path":"2016/06/25/git的基本使用/","text":"git的基本使用git init新创建一个项目文件夹之后，文件夹只是一个普通的文件夹，对于文件夹内任何内容的修改不会受到版本控制系统的管理。 我们需要为当前的项目文件夹初始化一个版本库，来管理当前项目。 1git init git init一个项目执行一次 git status查看当前git仓库的状态信息 git add告诉git要追踪管理哪些文件1234git add 文件名git add * git add -A git commit告诉git 帮我生成一个新的版本1git commit -m \"版本的描述信息\" git log可以查看所有的已经提交的版本信息版本的版本号修改的作者修改的时间版本的说明 设置用户名和邮箱的命令只需要执行一次（一个电脑执行一次）12git config --global user.name 用户名git config --global user.email 邮箱 git checkout 文件名将暂存区的内容恢复到工作目录 git reset –hard 版本号（git log中去找）将版本库中指定的版本恢复到工作目录！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]